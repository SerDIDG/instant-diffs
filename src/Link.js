import id from './id';
import * as utils from './utils';

import Button from './Button';
import view from './View';

import './styles/links.less';

const { h, ht } = utils;

/**
 * Class representing a link.
 */
class Link {
    /**
     * @type {Element}
     */
    node;

    /**
     * @type {object}
     */
    options = {};

    /**
     * @type {object}
     */
    nodes = {};

    /**
     * @type {object}
     */
    page = {};

    /**
     * @type {object}
     */
    action = {};

    /**
     * @type {object}
     */
    mw = {
        hasLink: false,
        hasLine: false,
    };

    /**
     * @type {object}
     */
    manual = {
        hasLink: false,
        behavior: 'default',
    };

    /**
     * @type {boolean}
     */
    isLoading = false;

    /**
     * @type {boolean}
     */
    isLoaded = false;

    /**
     * @type {boolean}
     */
    isProcessed = false;

    /**
     * @type {boolean}
     */
    hasRequest = false;

    /**
     * Create a link instance.
     * @param {Element} node a link node
     * @param {object} [options] configuration options
     * @param {string} [options.behavior]
     * @param {string} [options.insertAfter]
     * @param {import('./Link').default} [options.initiatorLink] a Link instance
     * @param {import('./Diff').default} [options.initiatorDiff] a Diff instance
     * @param {View} [options.initiatorView] a View instance
     * @param {function} [options.onRequest] a callback
     * @param {function} [options.onLoad] a callback
     * @param {function} [options.onOpen] a callback
     * @param {function} [options.onClose] a callback
     */
    constructor( node, options ) {
        this.node = node;
        this.options = {
            behavior: 'default',            // default | basic | event | none
            insertMethod: 'insertAfter',
            initiatorLink: null,
            initiatorDiff: null,
            initiatorView: null,
            onRequest: () => {},
            onLoad: () => {},
            onOpen: () => {},
            onClose: () => {},
            ...options,
        };

        // Check if a link was opened from the View dialog
        if ( view.isContains( this.node ) ) {
            this.options.initiatorView = view;
            this.options.initiatorDiff = view.getDiff();
        }

        // Check if a link generated by MediaWiki
        this.mw.hasLink = utils.isMWLink( this.node, id.config.mwLink );
        if ( this.mw.hasLink ) {
            this.mw.link = this.node;

            this.mw.isAltTitle = utils.isMWLink( this.mw.link, id.config.mwLinkAltTitle );
            this.mw.isDiffOnly = utils.isMWLink( this.mw.link, id.config.mwLinkDiffOnly );
            this.mw.isExcluded = utils.isMWLink( this.mw.link, id.config.mwLinkExclude );
            if ( !this.mw.isExcluded ) {
                this.options.behavior = 'basic';
            }
            this.mw.isPrepend = utils.isMWLink( this.mw.link, id.config.mwLinkPrepend );
            if ( this.mw.isPrepend ) {
                this.options.insertMethod = 'insertBefore';
            }

            this.mw.line = utils.getMWDiffLine( this.mw );
            if ( this.mw.line ) {
                this.mw.hasLine = true;
                this.mw.title = utils.getMWDiffLineTitle( this.mw );
                this.mw.line.classList.add( 'instantDiffs-line' );
            }
        }

        // Check if a link was marked manually by the "data-instantdiffs-link" attribute: default | basic | event | none | link (deprecated)
        this.manual.behavior = this.node.dataset.instantdiffsLink;
        if ( this.manual.behavior === 'link' ) {
            this.manual.behavior = 'event';
        }
        if ( [ 'default', 'basic', 'event', 'none' ].includes( this.manual.behavior ) ) {
            this.options.behavior = this.manual.behavior;
            this.manual.hasLink = true;
        }

        // Validate configuration
        this.config = {
            ...utils.defaults(),
            ...{
                showPageLink: utils.defaults( 'showPageLink' ) && this.options.behavior === 'default',
            },
        };

        // Add a link node to the processed links set
        id.local.links.set( this.node, this );

        this.process();
    }

    process() {
        this.href = this.node.href;
        if ( utils.isEmpty( this.href ) ) return;

        // Validate url
        const urlParts = {};
        try {
            this.url = new URL( this.href );
            urlParts.title = this.url.searchParams.get( 'title' );
            urlParts.pathname = decodeURIComponent( this.url.pathname );
            urlParts.pathnameNormalized = urlParts.pathname.replace( new RegExp( id.local.mwArticlePath ), '' );
        } catch ( e ) {
            return;
        }

        // Get link origin and index.php endpoint
        this.page.origin = this.url.origin;
        this.page.mwEndPoint = `${ this.page.origin }${ mw.config.get( 'wgScript' ) }`;
        this.page.mwEndPointUrl = new URL( this.page.mwEndPoint );

        if ( id.local.specialPagesSearchRegExp.test( urlParts.title ) ) {
            // Get components from splitting url title
            this.page = { ...this.page, ...utils.getSplitSpecialUrl( urlParts.title ) };
        } else if ( id.local.specialPagesPathRegExp.test( urlParts.pathname ) ) {
            // Get components from splitting url pathname
            this.page = { ...this.page, ...utils.getSplitSpecialUrl( urlParts.pathnameNormalized ) };
        } else {
            // Get components from url search parameters
            const components = [ 'title', 'curid', 'oldid', 'diff', 'direction' ];
            components.forEach( component => {
                this.page[ component ] = this.url.searchParams.get( component );
            } );

            // As a last resort, get the page title from url pathname
            if ( utils.isEmpty( this.page.title ) && id.local.articlePathRegExp.test( urlParts.pathname ) ) {
                this.page.title = urlParts.pathnameNormalized;
            }
        }

        // Fix common user mistake with unnecessary pipeline following after the ids
        if ( !utils.isEmpty( this.page.diff ) && this.page.diff.indexOf( '|' ) > -1 ) {
            this.page.diff = this.page.diff.split( '|' ).shift();
        }
        if ( !utils.isEmpty( this.page.oldid ) && this.page.oldid.indexOf( '|' ) > -1 ) {
            this.page.oldid = this.page.oldid.split( '|' ).shift();
        }
        if ( !utils.isEmpty( this.page.curid ) && this.page.curid.indexOf( '|' ) > -1 ) {
            this.page.curid = this.page.curid.split( '|' ).shift();
        }

        // Populate the page title from the watchlist line entry for edge cases
        // Link minifiers like [[:ru:User:Stjn/minilink.js]] often remove titles from the links
        if ( utils.isEmpty( this.page.title ) && this.mw.hasLine ) {
            this.page.title = this.mw.title;
        }

        // Validate page object
        this.page = utils.validatePage( this.page );
        this.page = utils.extendPage( this.page );

        switch ( this.options.behavior ) {
            // Add an event on the existing link
            case 'event':
                this.renderEvent();
                break;

            // Render actions for the MediaWiki's link
            case 'basic':
                this.renderBasic();
                break;

            // Render actions lazily for the user-contributed links
            case 'default':
                this.renderRequest();
                break;
        }
    }

    /******* OBSERVER *******/

    observe() {
        if ( this.isObserved ) return;
        this.isObserved = true;
        id.local.observer.observe( this.node );
    }

    unobserve() {
        if ( !this.isObserved ) return;
        this.isObserved = false;
        id.local.observer.unobserve( this.node );
    }

    onIntersect() {
        if ( this.isLoading || this.isLoaded || !this.isObserved ) return;
        this.unobserve();
        this.request();
    }

    /******* REQUESTS *******/

    renderRequest() {
        this.hasRequest = this.page.isValid;

        if ( this.hasRequest ) {
            this.toggleSpinner( true );
            this.observe();
        } else {
            this.toggleSpinner( false );
            this.isLoaded = true;
            this.isProcessed = false;
            this.unobserve();
        }
    }

    request() {
        switch ( this.page.type ) {
            case 'revision':
                this.requestRevision();
                break;

            case 'diff':
                this.requestDiff();
                break;
        }
    }

    /******* REQUEST REVISION *******/

    requestRevision() {
        if ( this.isLoading ) return;

        this.isLoading = true;
        this.error = null;

        const params = {
            action: 'query',
            prop: 'revisions',
            rvprop: [ 'ids', 'timestamp', 'user', 'comment', 'content' ],
            rvslots: 'main',
            rvsection: 0,
            format: 'json',
            formatversion: 2,
            uselang: id.local.userLanguage,
        };

        if ( !utils.isEmpty( this.page.oldid ) ) {
            params.revids = this.page.oldid;
        } else if ( !utils.isEmpty( this.page.curid ) ) {
            params.pageids = this.page.curid;
        }

        return id.local.mwApi
            .get( params )
            .then( this.onRequestRevisionDone.bind( this ) )
            .fail( this.onRequestRevisionError.bind( this ) );
    }

    onRequestRevisionError( error, data ) {
        this.isLoading = false;

        this.error = {
            type: 'revision',
            code: !utils.isEmpty( this.page.curid ) ? 'curid' : 'generic',
        };

        if ( data?.error ) {
            this.error.code = data.error.code;
            this.error.message = data.error.info;
        } else {
            this.error.message = error;
            utils.notifyError( `error-revision-${ this.error.code }`, this.error, this.page, true );
        }

        this.renderError();
    }

    onRequestRevisionDone( data ) {
        this.isLoading = false;

        // Render error if the query request is completely failed
        const query = data?.query;
        if ( !query || ( !query.badrevids && !query.badpageids && !query.pages ) ) {
            return this.onRequestRevisionError( null, data );
        }

        // Get a page for the query request
        const page = query.pages?.[ 0 ];
        const revision = page?.revisions?.[ 0 ];

        // Check for a specific error code
        const error = { type: 'revision' };
        if ( query.badrevids ) {
            error.code = 'badrevids';
        } else if ( query.badpageids ) {
            error.code = 'badpageids';
        } else if ( !page || page.missing || !revision ) {
            error.code = 'missing';
        } else if ( page.invalid ) {
            error.code = 'invalid';
            error.info = page.invalidreason;
        }

        // Render error if exist
        if ( error.code ) {
            this.error = error;
            return this.renderError();
        }

        this.revision = revision;
        this.page.isHidden = utils.isRevisionHidden( this.revision );
        this.page = utils.extendPage( this.page, {
            title: page.title,
            section: utils.getRevisionSection( this.revision ),
        } );

        this.renderSuccess();
    }

    /******* REQUEST DIFF *******/

    requestDiff() {
        if ( this.isLoading ) return;

        this.isLoading = true;
        this.error = null;

        const params = {
            action: 'compare',
            prop: [ 'title', 'ids', 'timestamp', 'user', 'comment' ],
            fromrev: utils.isValidID( this.page.oldid ) ? this.page.oldid : undefined,
            fromtitle: !utils.isEmpty( this.page.title ) ? this.page.title : undefined,
            torev: utils.isValidID( this.page.diff ) ? this.page.diff : undefined,
            torelative: utils.isValidDir( this.page.diff ) ? this.page.diff : undefined,
            format: 'json',
            formatversion: 2,
            uselang: id.local.userLanguage,
        };
        return id.local.mwApi
            .get( params )
            .then( this.onRequestDiffDone.bind( this ) )
            .fail( this.onRequestDiffError.bind( this ) );
    }

    onRequestDiffError( error, data ) {
        this.isLoading = false;

        this.error = {
            type: 'diff',
        };

        if ( data?.error ) {
            this.error.code = data.error.code;
            this.error.message = data.error.info;
        } else {
            this.error.message = error;
            utils.notifyError( 'error-diff-generic', this.error, this.page, true );
        }

        this.renderError();
    }

    onRequestDiffDone( data ) {
        this.isLoading = false;

        // Render error if the compare request is completely failed
        this.compare = data?.compare;
        if ( !this.compare ) {
            return this.onRequestDiffError( null, data );
        }

        this.page.isHidden = utils.isCompareHidden( this.compare );
        this.page = utils.extendPage( this.page, {
            title: utils.getCompareTitle( this.compare ),
            section: utils.getCompareSection( this.compare ),
        } );

        this.renderSuccess();
    }

    /******* RENDER *******/

    renderEvent() {
        if ( !this.page.isValid ) return;

        this.action.button = new Button( {
            node: this.node,
            handler: this.openDialog.bind( this ),
            ariaHaspopup: true,
        } );

        this.renderSuccess();
    }

    renderBasic() {
        if ( !this.page.isValid || ( this.mw.isDiffOnly && this.page.type !== 'diff' ) ) return;

        this.renderSuccess();
    }

    renderError() {
        this.isLoaded = true;
        this.isProcessed = false;
        this.toggleSpinner( false );

        // Render actions panel
        if ( this.options.behavior !== 'event' ) {
            this.renderWrapper();

            let messageName;
            if ( this.error.type ) {
                messageName = `error-${ this.error.type }-${ this.error.code || 'generic' }`;
                if ( !utils.isMessageExists( messageName ) ) {
                    messageName = `error-${ this.error.type }-generic`;
                }
            }

            this.nodes.error = h( 'span', {
                    class: [ 'item', 'error', 'error-info' ],
                    title: utils.getErrorMessage( messageName, this.error, this.page ),
                },
                ht( utils.getLabel( 'error' ) ),
            );
            this.nodes.inner.append( this.nodes.error );

            this.embed( this.node, this.options.insertMethod );
        }

        mw.hook( `${ id.config.prefix }.link.renderError` ).fire( this );
    }

    renderSuccess() {
        this.isLoaded = true;
        this.isProcessed = true;
        this.toggleSpinner( false );

        // Render actions panel
        if ( this.options.behavior !== 'event' ) {
            this.renderWrapper();

            if ( this.mw.hasLink || this.revision || this.compare ) {
                this.renderLinkAction();
            }
            if ( this.config.showPageLink ) {
                this.renderPageAction();
            }

            this.embed( this.node, this.options.insertMethod );
        }

        mw.hook( `${ id.config.prefix }.link.renderSuccess` ).fire( this );
    }

    renderWrapper() {
        this.nodes.container = this.nodes.inner = h( 'span', { class: [ 'instantDiffs-panel', 'nowrap', 'noprint' ] } );
    }

    renderAction( params ) {
        params = {
            tag: 'a',
            label: null,
            title: null,
            href: null,
            target: utils.getTarget( this.options.initiatorView ),
            handler: null,
            classes: [],
            modifiers: [],
            container: this.nodes.inner,
            ...params,
        };

        params.classes = [ 'item', 'text', 'instantDiffs-action', ...params.classes ];
        params.modifiers.forEach( modifier => params.classes.push( `instantDiffs-action--${ modifier }` ) );

        return new Button( params );
    }

    getLinkTitle( title ) {
        // Get an original title from the link
        if ( this.mw.isAltTitle && !utils.isEmpty( this.node.title ) ) {
            return this.node.title;
        }

        // Indicate about hidden revisions
        if ( this.page.isHidden ) {
            title = `${ title }-hidden`;
        }

        return utils.msg( title );
    }

    renderLinkAction() {
        const title = this.getLinkTitle( `${ this.page.type }-title` );

        if ( !utils.defaults( 'showLink' ) ) {
            return this.mutateLinkAction( title );
        }

        const classes = [];
        if ( this.page.isHidden ) {
            classes.push( 'error', 'error-admin' );
        }

        this.action.button = this.renderAction( {
            label: utils.getLabel( this.page.type ),
            title: title,
            classes: classes,
            modifiers: [ this.page.type ],
            handler: this.openDialog.bind( this ),
            ariaHaspopup: true,
        } );
    }

    mutateLinkAction( title ) {
        const classes = [ 'instantDiffs-link', `instantDiffs-link--${ this.page.type }`, `is-${ this.options.insertMethod }` ];
        if ( this.page.isHidden ) {
            classes.push( 'instantDiffs-link--error' );
        }

        this.node.classList.remove( 'external' );
        this.node.classList.add( ...classes );
        this.node.setAttribute( 'data-instantdiffs-link', this.options.behavior );

        this.action.button = new Button( {
            node: this.node,
            handler: this.openDialog.bind( this ),
            ariaHaspopup: true,
            altTitle: title,
            useAltKey: true,
        } );
    }

    renderPageAction() {
        this.page.button = this.renderAction( {
            label: utils.getLabel( 'page' ),
            //title: utils.msg( 'page-title' ),
            title: this.page.titleTextSection || this.page.titleText,
            href: this.page.href,
            modifiers: [ 'page' ],
        } );
    }

    /******* DIALOG *******/

    openDialog() {
        const options = {
            initiatorDiff: this.options.initiatorDiff,
            onOpen: () => this.onDialogOpen(),
            onClose: () => this.onDialogClose(),
        };
        const isReady = view.setup( this, options );
        if ( !isReady ) return;

        this.onDialogRequest();
        $.when( view.load() )
            .always( () => this.onDialogLoad() );
    }

    /**
     * Event that emits before the View dialog loads.
     */
    onDialogRequest() {
        this.toggleLoader( true );

        if ( utils.isFunction( this.options.onRequest ) ) {
            this.options.onRequest( this );
        }
    }

    /**
     * Event that emits after the View dialog loads.
     */
    onDialogLoad() {
        this.toggleLoader( false );

        if ( utils.isFunction( this.options.onLoad ) ) {
            this.options.onLoad( this );
        }
    }

    /**
     * Event that emits after the View dialog opens.
     */
    onDialogOpen() {
        if ( this.mw.hasLine && this.config.highlightLine ) {
            this.mw.line.classList.add( 'instantDiffs-line--highlight' );
        }

        if ( utils.isFunction( this.options.onOpen ) ) {
            this.options.onOpen( this );
        }

        if ( this.options.initiatorLink instanceof Link ) {
            this.options.initiatorLink.onDialogOpen();
        }
    }

    /**
     * Event that emits after the View dialog closes.
     */
    onDialogClose() {
        if ( this.mw.hasLine ) {
            if ( this.config.highlightLine ) {
                this.mw.line.classList.remove( 'instantDiffs-line--highlight' );
            }
            if (
                this.config.markWatchedLine &&
                id.config.changeLists.includes( mw.config.get( 'wgCanonicalSpecialPageName' ) )
            ) {
                this.mw.line.classList.remove( ...id.config.mwLine.unseen );
                this.mw.line.classList.add( ...id.config.mwLine.seen );
            }
        }

        if ( utils.isFunction( this.options.onClose ) ) {
            this.options.onClose( this );
        }

        if ( this.options.initiatorLink instanceof Link ) {
            this.options.initiatorLink.onDialogClose();
        }
    }

    /******* ACTIONS *******/

    /**
     * Toggle a pending loader cursor visibility.
     * @param {boolean} value
     */
    toggleLoader( value ) {
        if ( this.action.button ) {
            this.action.button.pending( value );
        } else {
            this.node.classList.toggle( 'instantDiffs-link--pending', value );
        }
    }

    /**
     * Toggle a spinner loader visibility.
     * @param {boolean} value
     */
    toggleSpinner( value ) {
        const classes = utils.getPlaceholderClasses( [ 'loader', this.page.type ] );

        if ( value ) {
            this.node.classList.add( ...classes );
        } else {
            this.node.classList.remove( ...classes );
        }
    }

    /**
     * Append a link's panel bar to the specified node.
     * @param {Element} container
     * @param {string} [insertMethod]
     */
    embed( container, insertMethod ) {
        utils.embed( this.nodes.container, container, insertMethod );
    }

    /**
     * Get a link's panel bar node.
     * @returns {Element}
     */
    getContainer() {
        return this.nodes.container;
    }

    /**
     * Get a link's node.
     * @returns {Element}
     */
    getNode() {
        return this.node;
    }

    /**
     * Get the initiator Link.
     * @returns {import('./Link').default}
     */
    getInitiatorLink() {
        return this.options.initiatorLink || this;
    }

    /**
     * Get page.
     * @returns {object}
     */
    getPage() {
        return this.page;
    }
}

export default Link;